#!/usr/bin/env python3
# Copyright (c) 2015 Jonathan Dowland <jon@dowland.me>
# distributed under the terms of the GNU Public License (GPL) Version 2 only
import struct, sys, re, os

usage = "pickmaps instructions.txt <outfile.wad>\n\n"+\
        "if outfile.wad is not supplied, the output filename will be \n"+\
        "the input file with the suffix changed to .wad.\n"

def parseinstr(fh):
    files, mappings = [], []
    for line in fh:
        if re.match(r' *($|#)', line):
            continue
        md = re.match(r'([0-9]+) +([0-9]+) +([0-9]+) +([0-9]+)', line)
        if md:
            mappings.append([int(x) for x in md.groups()])
        else:
            if len(mappings) > 0:
                raise Exception("mappings must come after all input file declarations\n")
            files.append(line[:-1])
    return files, mappings

def getmap(fh):
    """Get the COLORMAP out of filehandle fh. If it's a WAD,
       seek accordingly. If not, assume it's a raw lump."""
    header = fh.read(12)
    wad, numents, diroffs = struct.unpack('<4sll', header)

    if wad[1:] == b'WAD' and wad[0] in b'PI':
        fh.seek(diroffs)
        loffs = 0
        for i in range(0,numents):
            offs,size,name = struct.unpack('<ll8s', fh.read(16))
            if name == b'COLORMAP':
                loffs = offs
                break
        if loffs == 0: # no COLORMAP in WAD
            raise IOError("synthetic IOError")
        fh.seek(loffs)
        lump = fh.read(256*34)
    else: # raw
        lump = header + fh.read(34 * 256 - len(header))

    if len(lump) != 34 * 256:
        raise IOError("lump too short")
    return lump

def verify_mapping(sources, src,ss,se,ds):
    if src not in range(0,len(sources)):
        raise Exception("src %d out of range\n" % src)
    for o in ss, se, ds:
        if o not in range (0,34):
            raise Exception("map selector %d out of range\n" % o)
    if ss > se or se - ss + ds > 33:
            raise Exception("range %d-%d too large for %d\n", ss,se,ds)

if __name__ == "__main__":
    if len(sys.argv) not in [2,3]:
        sys.stderr.write(usage)
        sys.exit(1)

    instr = sys.argv[1]
    outf = os.path.splitext(instr)[0] + ".wad"
    if len(sys.argv) == 3:
        outf = sys.argv[2]

    with open(instr, "r") as fh:
        files, mappings = parseinstr(fh)

    # read in source colormaps
    sources = []
    for fn in files:
        try:
            with open(fn,'rb') as fh:
                sources.append(getmap(fh))
        except IOError as e:
            sys.stderr.write(e.filename+": "+e.strerror+"\n")
            sys.exit(1)

    outlumps = [ b'' for x in range(0,34) ]

    for src, ss, se, ds in mappings:
        verify_mapping(sources, src, ss, se, ds)
        for i in range(ss, se + 1):
            outlumps[ds + i - ss] = sources[src][i*256:i*256 + 256]

    # output time!
    with open(outf,'wb') as fh:
        sig = b'Generated by pickmaps: http://jmtd.net/doom/'
        fh.write(struct.pack('<4sll', b'PWAD', 1, 12 + 34*256 + len(sig)) +
            b''.join(outlumps) +
            sig + struct.pack('<ll8s', 12, 256*34, b'COLORMAP'))
